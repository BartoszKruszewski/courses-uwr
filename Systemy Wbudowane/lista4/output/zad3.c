#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <stdlib.h>
#include <util/delay.h>

const uint8_t gamma_table[256] PROGMEM = {
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,   2,   2,   3,
    3,   3,   3,   3,   4,   4,   4,   4,   5,   5,   5,   5,   6,   6,   6,   7,
    7,   7,   8,   8,   8,   9,   9,   9,  10,  10,  11,  11,  11,  12,  12,  13,
   13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  18,  19,  19,  20,  20,  21,
   22,  22,  23,  23,  24,  25,  25,  26,  26,  27,  28,  28,  29,  30,  30,  31,
   32,  33,  33,  34,  35,  35,  36,  37,  38,  38,  39,  40,  41,  42,  42,  43,
   44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  56,  57,
   58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  73,  74,
   75,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  91,  92,
   93,  94,  95,  97,  98,  99, 100, 102, 103, 104, 105, 107, 108, 109, 111, 112,
  113, 115, 116, 117, 119, 120, 121, 123, 124, 126, 127, 128, 130, 131, 133, 134,
  136, 137, 139, 140, 142, 143, 145, 146, 148, 149, 151, 152, 154, 155, 157, 159,
  160, 162, 163, 165, 167, 168, 170, 172, 173, 175, 177, 178, 180, 182, 184, 185,
  187, 189, 191, 192, 194, 196, 198, 200, 201, 203, 205, 207, 209, 211, 213, 214,
  216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246,
};

const uint8_t PROGMEM sine_table[256] = {
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254,
    252, 250, 248, 245, 242, 239, 236, 233, 230, 227, 224, 221, 218, 215, 212, 209,
    206, 203, 200, 197, 194, 191, 188, 185, 182, 179, 176, 173, 170, 167, 164, 161,
    158, 155, 152, 149, 146, 143, 140, 137, 134, 131, 128, 125, 122, 119, 116, 113,
    110, 107, 104, 101, 98,  95,  92,  89,  86,  83,  80,  77,  74,  71,  68,  65,
    62,  59,  56,  53,  50,  47,  44,  41,  38,  35,  32,  29,  26,  23,  20,  17,
    14,  11,  8,   5,   3,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   3,
    5,   8,   11,  14,  17,  20,  23,  26,  29,  32,  35,  38,  41,  44,  47,  50,
    53,  56,  59,  62,  65,  68,  71,  74,  77,  80,  83,  86,  89,  92,  95,  98,
    101, 104, 107, 110, 113, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146,
    149, 152, 155, 158, 161, 164, 167, 170, 173, 176, 179, 182, 185, 188, 191, 194,
    197, 200, 203, 206, 209, 212, 215, 218, 221, 224, 227, 230, 233, 236, 239, 242,
    245, 248, 250, 252, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
};


void hsv_to_rgb(uint16_t h, uint8_t *r, uint8_t *g, uint8_t *b)
{
    uint8_t region, remainder, p, q, t;

    region = h / 60;
    remainder = (h % 60) * 255 / 60;

    p = 0;
    q = 255 - remainder;
    t = remainder;

    switch (region)
    {
    case 0:
        *r = 255;
        *g = t;
        *b = p;
        break;
    case 1:
        *r = q;
        *g = 255;
        *b = p;
        break;
    case 2:
        *r = p;
        *g = 255;
        *b = t;
        break;
    case 3:
        *r = p;
        *g = q;
        *b = 255;
        break;
    case 4:
        *r = t;
        *g = p;
        *b = 255;
        break;
    default:
        *r = 255;
        *g = p;
        *b = q;
        break;
    }
}

void set_color(uint8_t r, uint8_t g, uint8_t b)
{
    OCR1A = 255 - pgm_read_byte(&gamma_table[r]);
    OCR1B = 255 - pgm_read_byte(&gamma_table[g]);
    OCR2A = 255 - pgm_read_byte(&gamma_table[b]);
}

void pwm_init()
{
    // Timer1 dla PB1 (D9) i PB2 (D10)
    DDRB |= (1 << PB1) | (1 << PB2);
    TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM10);
    TCCR1B = (1 << WGM12) | (1 << CS11);

    // Timer2 dla PB3 (D11)
    DDRB |= (1 << PB3);
    TCCR2A = (1 << COM2A1) | (1 << WGM21) | (1 << WGM20);
    TCCR2B = (1 << CS21);

    OCR1A = 0;
    OCR1B = 0;
    OCR2A = 0;
}

uint8_t dim_light(uint8_t base, uint8_t dimming)
{
    if (dimming > base)
        return 0;
    return base - dimming;
}

int main(void)
{
    pwm_init();
    srand(42);

    uint8_t base_r, base_g, base_b;
    uint8_t breath_idx = 0;
    uint8_t dimming;

    while (1)
    {
        if (breath_idx++ == 0) hsv_to_rgb(rand() % 360, &base_r, &base_g, &base_b);
        dimming = pgm_read_byte(&sine_table[breath_idx]);

        set_color(dim_light(base_r, dimming), dim_light(base_g, dimming), dim_light(base_b, dimming));
        _delay_ms(10); // Pe≈Çny cykl: ~2.5 sekundy (255 * 10ms)
    }

    return 0;
}
