# Wykład 4 - Wzorce kreacyjne

### 1.1 Interface vs Abstract class

- Klasa abstrakcyjna może zawierać implementacje metod, interfejs nie.
- Dziedziczenie możliwe jest tylko z jednej klasy abstrakcyjnej, natomiast interfejsów może być wiele.

### 1.2 Delegacja (Prefer Delegation over Inheritance)

- Dziedziczenie jest statyczne (określone na etapie kompilacji), delegacja może być dynamiczna (w czasie działania).
- Delegujący obiekt może ukrywać metody obiektu delegowanego lub zmieniać jego kontrakt – co nie jest możliwe przy dziedziczeniu.
- Przykład dobrej praktyki: zamiast `Person` dziedziczącego z `Hashtable`, lepiej żeby `Person` delegował do `Hashtable`.
- Delegacja zwiększa ilość kodu – wiele języków (np. C#) nie wspiera jej składniowo, chociaż są propozycje rozszerzeń.

## 2. Wzorce kreacyjne

### 2.1 Singleton

- Zapewnia istnienie tylko jednej instancji klasy, współdzielonej przez wszystkich klientów.
- Często wykorzystywany jako centralny punkt startowy architektury.

### 2.2 Monostate

- Znosi ograniczenie jednej instancji z Singletona, ale wszystkie instancje dzielą ten sam stan.
- Klasy mogą być wielokrotnie instancjonowane, ale zachowują się jak Singleton poprzez współdzielenie danych.

### 2.3 (Delegate) Factory

- Realizuje odpowiedzialność typu **Creator** z GRASP.
- Fabryka może posiadać wiele metod tworzących różne typy obiektów.
- Może zwracać obiekty podtypów oczekiwanych przez klienta.
- Może kontrolować czas życia obiektów.

**Zalety:**
- Umożliwia rozszerzanie aplikacji bez naruszania istniejącego kodu (Zasada OCP).
- Zapewnia stabilny interfejs (Law of Demeter – GRASP).
- Może zastępować Singletony i Monostaty zapewniając lepszą elastyczność.

### 2.4 Factory Method

- Delegowanie tworzenia obiektu do metody fabrykującej, zazwyczaj abstrakcyjnej.
- Umożliwia użycie metody fabrykującej w klasach bazowych (przed implementacją).
- Konkretne podklasy dostarczają implementacji tworzenia.

### 2.5 Abstract Factory

- Nazywany również „toolkitem”.
- Zapewnia tworzenie całej rodziny powiązanych obiektów.
- Klient nie tworzy obiektów samodzielnie, lecz zleca to fabryce.

**Różnice względem Factory Method:**
- W FM klasa użytkowa sama tworzy obiekty pomocnicze.
- W AF tworzenie jest w pełni delegowane do osobnej fabryki.
- Klient z AF odpowiada Creatorowi z FM.

**Refaktoryzacja:** z FM do AF zachodzi przy zwiększeniu liczby typów tworzonych obiektów.

### 2.6 Prototype

- Tworzenie nowych obiektów przez kopiowanie istniejących prototypów.
- Nieistotne jest, jak prototyp został utworzony.
- Przydatne przy dynamicznym tworzeniu złożonych struktur.

### 2.7 Object Pool

- Wzorzec do zarządzania pulą „ciężkich” obiektów, które są kosztowne w tworzeniu.
- Zamiast tworzyć nowe obiekty, są one współdzielone i zwracane do puli.

### 2.8 Builder

- Stopniowe konstruowanie obiektów
- Ukrywa szczegóły procesu konstruowania złożonych obiektów.
- Ułatwia tworzenie struktur skomplikowanych wewnętrznie.
