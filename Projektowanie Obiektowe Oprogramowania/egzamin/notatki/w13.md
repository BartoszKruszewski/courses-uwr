# Wykład 13 - Testowanie oprogramowania

## 1. Wprowadzenie

Współczesne testowanie obejmuje nie tylko testy jednostkowe, ale również użycie narzędzi wspierających:

- **Obiekty zastępcze (mock objects)** – eliminują potrzebę pisania własnych implementacji zastępczych.
- **Automatyczne generowanie przypadków testowych** – na podstawie struktury kodu.
- **Dynamiczna i statyczna walidacja poprawności programów**.

## 2. TDD vs BDD

### TDD (Test-Driven Development)
- Programowanie sterowane testami.
- Główne pojęcia:
  - **SUT (System Under Test)** – testowana klasa użytkowa.
  - **Collaborators** – usługi pomocnicze, których SUT używa.

### AAA – Arrange / Act / Assert
Metodyka struktury testów:
1. **Arrange** – przygotowanie SUT i jego współpracowników.
2. **Act** – wykonanie akcji.
3. **Assert** – sprawdzenie oczekiwań.

### Czy używać prawdziwych usług pomocniczych?
**Nie!** Skutki uboczne (np. wysyłka maili) są niepożądane.

### Test Doubles (Dublerzy)
Rodzaje obiektów zastępczych:

- **Dummy** – nieużywana implementacja, tylko do wypełnienia zależności.
- **Stub** – zwraca spreparowane wyniki dla konkretnego testu.
- **Fake** – uproszczona, działająca wersja prawdziwej implementacji (np. zapis do pamięci).
- **Mock** – w pełni kontrolowany obiekt używany w testach BDD.

### BDD (Behavior-Driven Development)
- Rozszerzenie TDD – testowanie **zachowania**, a nie stanu.

#### Co testuje BDD?
- Czy SUT wywołuje odpowiednie metody collaboratorów.
- Czy parametry i liczba wywołań są właściwe.
- Czy kolejność wywołań jest zgodna z oczekiwaniami.

#### Zalety
- Unikanie wielokrotnego `Act-Assert` dzięki skupieniu na interakcjach.

## 3. Design by Contract (DbC)

Technika projektowania obiektowego, gdzie kontrakty stają się częścią interfejsu klasy:

- **Precondition** – warunek przed rozpoczęciem metody.
- **Postcondition** – warunek po zakończeniu metody.
- **Invariant** – warunek, który musi być zawsze spełniony.

### Język do wyrażania kontraktów
- **OCL (Object Constraint Language)** – logika pierwszego rzędu.

### Weryfikacja kontraktów
- **Dynamiczna** – np. przez `Contract.Ensures`, `Contract.Requires`.
- **Statyczna** – niepraktyczna ze względu na nierozstrzygalność.

### Przykład użycia kontraktów:
- `Abs(x)` – gwarantuje, że wynik ≥ 0.
- `Swap(ref x, ref y)` – zapewnia zamianę wartości.

## 4. Testowanie UI – UI Automation

Testy akceptacyjne poprzez interfejs użytkownika.

### Technologie:
- **UI Automation** (MS Windows).
- **White** – wygodniejsze API na bazie UI Automation.
- **WebDriver** – standard od 2004.
- **Playwright** – nowoczesna platforma do automatyzacji przeglądarek.
- **Puppeteer** – biblioteka do automatyzacji Chrome (od 2017).
