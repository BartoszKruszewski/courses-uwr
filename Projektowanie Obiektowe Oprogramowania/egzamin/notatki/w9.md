# Wykład 9 - Wzorce architektury aplikacji

## 1. Automated Code Generation

Technika wspomagająca, polegająca na generowaniu kodu przez automat w sposób deklaratywny. 

- **Elementy imperatywne**: zawarte w blokach `<# … #>`, wykonywane jako kod.
- **Elementy deklaratywne**: kopiowane bez zmian do wyjścia.

## 2. Object-Relational Mapping (ORM)

Rozwiązanie problemu niezgodności świata obiektowego z relacyjnym.
Umożliwia pracę z bazą danych przy użyciu obiektów.

### Przykładowe implementacje:
- Hibernate / nHibernate (Java / .NET)
- Entity Framework (.NET)
- JPA (Java)
- Sequelize (Node.js)
- Active Record (Ruby)

### 2.1 Database First / Model First / Code First

- **Database First**: najpierw struktura relacyjna, model generowany automatycznie.
- **Model First**: najpierw model mapowania, potem baza i klasy.
- **Code First**: najpierw klasy, a struktura bazy generowana przez narzędzie.

Obecnie używa się głównie **Code First**

### 2.2 Metadata Mapping

Strategie definiowania metadanych:
- **W klasach** (np. atrybuty, dziedziczenie).
- **Zewnętrzne** (np. XML, API).

Niektóre technologie wspierają **migracje** — wersjonowanie modelu relacyjnego.

### 2.3 Lazy Loading

Ładowanie danych tylko na żądanie — unika nadmiarowego ładowania danych powiązanych.

#### Techniki:
1. **Lazy initialization** – kod z flagą `isLoaded`.
2. **Virtual proxy** – proxy z automatycznym ładowaniem danych.
3. **Value holder** – delegacja pobierania danych do osobnego obiektu.

### 2.4 Relacje

Mapowanie relacji jeden-do-jednego:
- Jedna klasa odwzorowana w dwóch tabelach (split entity).
- Dwie klasy powiązane relacją.

Relacja wiele-do-wiele odwzorowana jako tabela asocjacyjna.
Silnik ORM może nią zarządzać automatycznie lub wymagać jawnego modelowania.

### 2.6 Dziedziczenie

#### Strategie:
1. **Concrete Table (TPC)** – jedna tabela na klasę:
   - Proste, ale problemy z identyfikatorami i relacjami.
2. **Single Table (TPH)** – jedna tabela na całą hierarchię:
   - Kolumna dyskryminatora, ale dużo `NULL`, łamie 3NF.
3. **Class Table (TPT)** – osobna tabela na każdą klasę:
   - Poprawna normalizacja, ale złożone zapytania.

### 2.7 1st Level Cache (Identity Map)

Buforowanie obiektów w kontekście zapytań po ID — przypisanie ID → obiekt.

### 2.8 2nd Level Cache

Buforowanie wybranych zapytań — jawne zarządzanie cache, możliwość wymiany implementacji.

### 2.9 Język Zapytaniowy

Języki obiektowe do zapytań:
- **LINQ** (C#)
- **HQL / JPQL** (Hibernate, JPA)
- **Criteria API** (Java)

### 2.12 Global Filter

Możliwość ustawienia filtrów globalnych (np. dla daty obowiązywania) — stosowane automatycznie w zapytaniach.

### 2.13 Soft Delete

Logiczne usuwanie — znakowanie rekordu zamiast fizycznego usunięcia.

#### Zalety:
- Szybsze niż DELETE.
- Możliwość audytu i przywrócenia.

#### Wady:
- Wymaga uwzględnienia kolumny `IsDeleted` w zapytaniach.
