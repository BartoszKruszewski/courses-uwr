# Wykład 3: SOLID, GRASP

## 1. Responsibility-Driven Development (RDD)

Projektowanie obiektowe = określanie odpowiedzialności obiektów (klas) i ich relacji.

**Odpowiedzialność** – kontrakt związany z:
- **Działaniem**: tworzenie, obliczenia, inicjalizacja, kontrola innych obiektów.
- **Wiedzą**: dane, wiedza o innych obiektach.

**RDD** = przemyślane projektowanie poprzez właściwe przypisywanie odpowiedzialności klasom.

### Skrajności w projektowaniu:
- Jedna ogromna klasa zawierająca wszystko.
- Mnóstwo klas z jedną metodą.

## 2. GRASP – General Responsibility Assignment Software Patterns

### 2.1 Creator

Kto tworzy instancje klasy A?

**Rozwiązanie**: Klasa B, jeśli:
- Zawiera lub agreguje A
- Zapamiętuje A
- Używa A
- Posiada dane inicjalizacyjne dla A

### 2.2 Information Expert

Komu przydzielić odpowiedzialność?

**Rozwiązanie**: Temu, kto posiada niezbędne informacje (ekspertowi).

### 2.3 Controller

Kto spoza GUI kontroluje żądania systemowe?

**Rozwiązanie**: Klasa:
- Reprezentująca system
- Reprezentująca przypadek użycia (np. `LoginHandler`)

### 2.4 Low Coupling

Jak zmniejszyć zależności i zwiększyć możliwość ponownego użycia?

**Rozwiązanie**: Ogranicz liczbę powiązań między klasami.

### 2.5 High Cohesion

Jak tworzyć klasy z jasnym celem i łatwe w utrzymaniu?

**Rozwiązanie**: Wysoka spójność wewnętrzna klasy (metody ściśle powiązane).

**Przykład**:
- Klasa `Samochód` wykonująca zbyt wiele zadań → podzielić na mniejsze klasy (`Kierowca`, `Mechanik`, `Myjnia`)

### 2.6 Polymorphism

Jak obsługiwać warunki zależne od typu?

**Rozwiązanie**: Używaj operacji polimorficznych dla typów o różnych zachowaniach.

### 2.7 Indirection

Jak uniknąć bezpośrednich zależności między obiektami?

**Rozwiązanie**: Wprowadzenie obiektu pośredniczącego.

### 2.8 Pure Fabrication

Jak zachować Low Coupling i High Cohesion, gdy nie działa Information Expert?

**Rozwiązanie**: Wprowadź sztuczną klasę pomocniczą (np. `OrderRepository`).

### 2.9 Protected Variations (Law of Demeter)

Jak projektować odporne na zmiany komponenty?

**Rozwiązanie**: Otocz punkty zmienności stabilnym interfejsem.  
Prawo Demeter = „nie rozmawiaj z nieznajomymi”.

## 3. SOLID – Pięć zasad obiektowych

### 3.1 SRP – Single Responsibility Principle
- Klasa powinna mieć tylko jedną odpowiedzialność.
- **Test SRP**: czy klasa może być zmodyfikowana z więcej niż jednego powodu?

### 3.2 OCP – Open-Closed Principle
- Otwarte na rozszerzenia, zamknięte na modyfikacje.

**Sposoby realizacji**:
- Zależność od abstrakcji
- Polimorfizm
- Strategie, szablony, delegacje

### 3.3 LSP – Liskov Substitution Principle
- Obiekt klasy potomnej musi być zamienny z klasą bazową (semantycznie, nie tylko składniowo).

**Zasada**:
- Dozwolone: osłabienie warunku wejścia, wzmocnienie warunku wyjścia.
- Naruszenia:
  - Zwracanie `null` zamiast wartości
  - Zaostrzenie wymagań wejściowych (np. `Set` zamiast `List`)

### 3.4 ISP – Interface Segregation Principle
- Klasy nie powinny być zmuszane do implementacji metod, których nie używają.

### 3.5 DIP – Dependency Inversion Principle
- Moduły wysokiego poziomu powinny zależeć od abstrakcji, nie od szczegółów.

## 4. Inne zasady

### 4.1 DRY – Don’t Repeat Yourself
Unikaj powtórzeń kodu i odpowiedzialności.

### 4.2 Law of Demeter
= Protected Variations (zasada najmniejszej wiedzy)

### 4.3 DMMT – Don’t Make Me Think
Projektuj intuicyjne interfejsy.

### 4.4 DOP – Don’t Optimize Prematurely
Nie optymalizuj zbyt wcześnie.

## 5. Miary jakościowe (metryki R. Martina)

- **Ce**: zależności *od* innych pakietów
- **Ca**: zależności *na* dany pakiet
- **I** = Ce / (Ce + Ca) – niestabilność
- **A** = Ta / (Ta + Tc) – abstrakcyjność
- **D** = |A + I – 1| – odległość od ideału

**Preferencje**:
- I ∈ [0, 0.3] → fundament
- I ∈ [0.7, 1] → fasada
