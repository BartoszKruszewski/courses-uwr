# Wykład 10 - Wzorce architektury aplikacji 2

## Inversion of Control / Dependency Injection

### 1. Inversion of Control vs Dependency Injection

- **Inversion of Control (IoC)** – zbiór technik pozwalających tworzyć luźno powiązane struktury klas.
- **Dependency Injection (DI)** – konkretna implementacja IoC w językach obiektowych.

Korzyści:
- **Późne wiązanie** – zmiana implementacji bez rekompilacji.
- **Ułatwienie testowania** – podstawianie stubów/fake’ów.
- **Uniwersalna fabryka** – dynamiczne tworzenie instancji typów.

### 2. Dependency Inversion Principle (DIP)

**Zalety:**
- Rozszerzalność (zgodność z OCP)
- Równoległa implementacja dzięki interfejsom
- Lepsza konserwowalność
- Niezależne testowanie klas
- Możliwość późnego określenia implementacji

### 3. Twarde vs Miękkie zależności

- **Twarde (stable)** – zależności do stabilnych, istniejących modułów.
- **Miękkie (volatile)** – zależności konfigurowane dynamicznie, np. przez kontener DI.
- **Spoina (seam)** – miejsce, gdzie zależność jest reprezentowana przez interfejs.

**Uwaga:** Zależność do samego frameworka DI jest zwykle twarda.

### 4. Kluczowe podwzorce Dependency Injection

#### 4.1 Składanie obiektów (Composition)

- **Kontener (kernel)** – odpowiedzialny za tworzenie instancji i rozwiązywanie zależności.
- **Rejestrowanie typów** – zarówno konkretnych (sztywnych), jak i interfejsów (miękkich).
- **Rejestrowanie instancji** – umożliwia kontrolę nad pojedynczym obiektem.
- **Cykl w grafie zależności** – potencjalny problem.
- **Wstrzykiwanie zależności:**
  - przez konstruktor (zalecane)
  - przez metodę (atrybut `[InjectionMethod]`)
  - przez właściwość (atrybut `[Dependency]`)
- **BuildUp** – uzupełnianie już istniejącego obiektu zależnościami.
- **Injection Factory** – możliwość wytwarzania zależności poprzez złożoną logikę.

#### 4.2 Zarządzanie czasem życia obiektów (Lifecycle Management)

- **Transient** – nowy obiekt za każdym razem.
- **ContainerControlled** – singleton.
- **Hierarchical** – singleton per podkontener.
- **PerThread** – inny obiekt na każdy wątek.
- **PerHttpContext** – nowy obiekt na każde żądanie HTTP.
- **Custom** – niestandardowy cykl życia.

#### 4.3 Konfiguracja kontenera

- **Deklaratywna** – XML, np. `unity.config`.
- **Imperatywna** – w kodzie (np. `RegisterType`).
- **Autokonfiguracja** – automatyczne mapowanie typów z pakietu.

#### 4.4 Przechwytywanie żądań (Proxy)

**Typowe zastosowania:**
- Audytowanie, logowanie, monitorowanie, bezpieczeństwo, cache’owanie, obsługa błędów.

**Rodzaje interceptorów:**
- `InterfaceInterceptor` – działa na metodach interfejsu.
- `VirtualMethodInterceptor` – działa na metodach wirtualnych.

### 6. Service Locator vs Composition Root + Local Factory

#### Service Locator (SL)

- Singleton kontenera dostępny globalnie.
- **Zalety**: redukcja zależności między klasami.
- **Wady (dlaczego antywzorzec):**
  - Wprowadza zależność do frameworka DI.
  - Ukrywa zależności (niejawne, trudne do śledzenia).

#### Composition Root (CR)

- Miejsce w aplikacji, gdzie rejestrowane są zależności (np. `Main`, `Application_Start`).
- Jedyny legalny punkt styku z DI.

#### Local Factory (Dependency Resolver)

- Wstrzykiwana fabryka lokalna odpowiedzialna za tworzenie instancji klas.
- Dzięki niej klasy są niezależne od frameworka DI.
- Fabryka ma miękką zależność – można ją łatwo wymienić, np. do testów.
