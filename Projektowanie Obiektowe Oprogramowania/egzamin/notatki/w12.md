# Wykład 12 - Wzorce architektury aplikacji 4

## 1. Architektura aplikacji

### 1.1 Diagram referencyjny
Architekturę aplikacji często przedstawia się jako stos warstw (od warstwy danych do interfejsu użytkownika). Stos to zestaw technologii wspierających implementację poszczególnych warstw.

### 1.2 Rodzaje aplikacji
- **Mobile Application**: obsługa scenariuszy offline, ograniczone zasoby.
- **Rich Client Application**: lokalne zasoby, możliwość działania offline.
- **Rich Internet Application**: bogaty interfejs, działa w przeglądarce.
- **Service Application**: luźne powiązania, komunikacja przez wiadomości XML.
- **Web Application**: tylko online, zasoby na serwerze.

### 1.3 Style architektury aplikacji
- **Client-Server**: klient żąda usług od serwera.
- **Component-Based**: aplikacja jako zestaw komponentów z interfejsami.
- **Layered Architecture**: podział aplikacji na warstwy.
- **Message-Bus**: komunikacja przez wiadomości.
- **MVC**: rozdzielenie interakcji użytkownika, logiki i danych.
- **N-tier / 3-tier**: podobna do Layered, ale z rozdziałem fizycznym.
- **SOA**: komponenty jako usługi wymieniające wiadomości.

### 1.4 Kryteria ewaluacji architektury
- **Availability**: czas działania systemu.
- **Conceptual Integrity**: spójność projektowa.
- **Flexibility**: możliwość adaptacji.
- **Interoperability**: wymiana danych między systemami.
- **Maintainability**: łatwość modyfikacji.
- **Manageability**: zarządzanie i monitoring.
- **Performance**: responsywność (latency, throughput).
- **Reliability**: zdolność do pracy bez awarii.
- **Reusability**: możliwość ponownego wykorzystania.
- **Scalability**: działanie przy wzroście obciążenia.
- **Security**: ochrona danych.
- **Supportability**: łatwość obsługi przez operatorów.
- **Testability**: możliwość testowania.
- **Usability**: jakość interakcji z użytkownikiem.

### 1.5 Kluczowe decyzje projektowe
- **Autoryzacja i uwierzytelnianie**
- **Zarządzanie stanem i cache'owaniem**
- **Komunikacja i współbieżność**
- **Zarządzanie konfiguracją**
- **Separacja odpowiedzialności**
- **Dostęp do danych i wyjątki**
- **Doświadczenie użytkownika**
- **Walidacja i workflow** 

## 2. Wzorce architektury warstwy interfejsu użytkownika

Celem wzorców UI jest separacja logiki aplikacyjnej od prezentacji, co umożliwia łatwiejsze testowanie oraz utrzymanie kodu.

### 2.1 Model-View-Controller (MVC)

- **Typ aplikacji**: Web Application
- **Interakcja**:
  - Użytkownik → Controller → Model + View → Użytkownik
- **Zalety**:
  - Controller jest tworzony przez framework na podstawie żądania.
  - Controller przygotowuje Model i wskazuje View do renderowania.
  - Testowalność przez możliwość wywoływania akcji kontrolera bez interfejsu.

### 2.2 Model-View-Presenter (MVP)

- **Typ aplikacji**: Rich Client Application
- **Interakcja**:
  - Użytkownik → View ⇄ Presenter → Model
- **Charakterystyka**:
  - Widok deleguje logikę do prezentera.
  - Prezenter steruje widokiem i przetwarza dane.
  - Wstrzykiwanie widoku do prezentera (interfejs).
- **Testowalność**:
  - Alternatywna implementacja widoku bez UI.
  - Prezenter testowalny niezależnie.
- **Refaktoryzacja do MVP**:
  - Utworzenie prezenterów i interfejsów dla formularzy.
  - Przeniesienie logiki ze zdarzeń UI do prezenterów.
  - Widoki implementują interfejsy, prezenter je steruje.

### 2.3 Model-View-ViewModel (MVVM)

- **Inspiracja MVP**, głównie dla WPF/XAML (.NET)
- **Różnice**:
  - Widok nie zawiera logiki (data-binding).
  - Widok korzysta tylko z ViewModelu (nie prezenter).
  - ViewModel wystawia dane do powiązań.
- **Zalety**:
  - Silna separacja.
  - Deklaratywność i prostota testowania.

## 3. Architektura Heksagonalna (Ports and Adapters / Onion Architecture)

- **Cel**: oddzielenie logiki biznesowej od wejścia/wyjścia aplikacji.
- **Zastosowanie**: Web i Rich Client.
- **Podział**:
  - **Porty pierwotne (wejściowe)**: klasy wykonujące przypadki użycia.
  - **Porty wtórne (wyjściowe)**: interfejsy np. do baz danych, e-maili itp.
- **Wzorce pomocnicze**:
  - Command dla portów pierwotnych.
  - Dependency Injection, Local Factory dla portów wtórnych.
- **Asymetria lewo-prawo**:
  - Porty pierwotne – konkretne klasy.
  - Porty wtórne – interfejsy.

### Architektura Czysta (Clean Architecture)
- Kombinacja Architektury Heksagonalnej i Domain-Driven Design (DDD).
- **DDD** – skupienie na modelu domenowym, nie definiuje reszty architektury.
- **Wnioski**:
  - Architektura heksagonalna ≠ DDD.
  - Możliwe użycie jednego bez drugiego.
  - Clean Architecture = Hex + DDD.

### Testowalność
- Porty pierwotne można testować bez UI.
- Porty wtórne można podmienić na "mocki".
